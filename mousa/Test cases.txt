All programs are initalized at location 0x000000000000 in instruction memory
Results can be checked via MARS simulator.
Programs can be tested in Modelsim via this benchtest segment of code inside Instruction_Memory module:

initial
begin
$readmemh("D:/Hazem/Private files/Backup/EN/Private files/Academic/3rd/CSE 311/work/IM.txt",Inst_Memory);
end

There must be a file (named "IM.txt") in "work" directory that contains Machine Codes in hexadecimal form.



Test case #1
Assembly code:
.text 
nop 
main: 
addi $s0,$0, 5
addi $s1,$0, 3
add $a0,$s0,$zero
add $a1,$s1,$zero
jal sum2
add $s2,$v0,$zero
sum2: 
addi $sp, $sp, -8
sw $ra, 4($sp)
sw $a1, 0($sp)
addi $s2,$0, 5
addi $s2, $s2, 5
add $s2, $s2, $s2
add $a1,$a0,$zero
jal sum
lw $a1, 0($sp)
lw $ra, 4($sp)
addi $sp, $sp, 8
add $v0, $v0, $a1
jr $ra
sum: 
addi $sp, $sp, -4
sw $s0, 0($sp)
add $s0, $a0, $a1
add $v0,$s0,$zero
lw $s0, 0($sp)
addi $sp, $sp, 4
jr $ra


Machine Code:
00000000
20100005
20110003
02002020
02202820
0c000007
00409020
23bdfff8
afbf0004
afa50000
20120005
22520005
02529020
00802820
0c000014
8fa50000
8fbf0004
23bd0008
00451020
03e00008
23bdfffc
afb00000
00858020
02001020
8fb00000
23bd0004
03e00008



Test Case #2
Assembly Code:
.text
	addi $s2, $zero, 1
	add $s1, $zero, $zero
	addi $s3, $zero, 10
For: 	slt $t0, $s3, $s2
	bne $t0, $zero, Exit
	sll $t1, $s2, 2
	add $s1, $s1, $t1
	addi $s2, $s2, 1
	j For
Exit:

Machine Code:
20120001
00008820
2013000a
0272402a
15000004
00124880
02298820
22520001
08000003


Test Case #3
Assembly Code:
.text
main:	addi $a1, $zero, 5
	addi $t0, $zero, 36
	jal func
	add $a0, $s4, $zero
	addi $s5, $a0, 25148581	# pseudo instruction that consists of lui, ori, add
	j exit
func:	addi $t1, $zero, 6
	add $s0, $t0, $zero
	add $s1, $zero, $zero
	loop: ble $s0, $zero, return	# pseudo instruction that consists of slt, beq
	sub $s0, $s0, $t1
	add $s1, $s1, $a1
	j loop
return:	add $s4, $s1, $zero
	jr $ra
exit:

Machine Code:
20050005
20080024
0c000008
02802020
3c01017f
3421bca5
0081a820
08000012
20090006
01008020
00008820
0010082a
10200003
02098022
02258820
0800000b
0220a020
03e00008

Test Case #4:
assembly code:-
addi $s0, $0, 1
add $s1, $0, $0
addi $t0, $0, 128
while: beq $s0, $t0, done
sll $s0, $s0, 1
addi $s1, $s1, 1
j while
done:
machine code in hexadecimal:-
0x20100001
0x00008820
0x20080080
0x12080003
0x00108040
0x22310001
0x08100003
used registers:-
$s0 ,$s1,$t0
expected output:-
$s0=128,$s1=8,$t0=128

Test Case #5:
assembly code:-
addi $s1, $0, 0
addi $s0, $0, 1
addi $t0, $0, 101
loop: slt $t1, $s0, $t0
beq $t1, $0, done
add $s1, $s1, $s0
sll $s0, $s0, 1
j loop
done:
---------------------
machine code in hexadecimal:-
0x20110000
0x20100001
0x20080065
0x0208482a
0x11200003
0x02308820
0x00108040
0x08100003
expected output:-
$s0=128
$s1=127
$t0=101

used registers:-
$s0 ,$s1,$t0
expected output:-
$s0=128,$s1=8,$t0=128

Test Case #6
assembly code:-
main:addi $a0, $0,2
addi $a1, $zero,3
addi $a2, $zero,4
addi $a3, $zero,5
jal diffofsums 
add $s0, $v0, $0 

diffofsums:
add $t0, $a0, $a1 
add $t1, $a2, $a3
sub $s0, $t0, $t1 
add $v0, $s0,$0
jr $ra
machine code in hexadecimal:-
0x20040002
0x20050003
0x20060004
0x20050003
0x20070005
0x0c100006
0x00408020
0x00850420
0x00c74820
0x01098022
0x02001020
0x03e00008

Test Case #7
assembly code:-
ADDI $sp, $sp, -4
ADDI $sp, $sp, -8
ADDI $sp, $sp, -12
ADDI $sp, $sp, -16
ADDI $sp, $sp, -20
ADDI $sp, $sp, -24
ADDI $sp, $sp, -28
ADDI $sp, $sp, -32
LW $s3, 0($sp)
diffofsums:
add $t0, $a0, $a1 
add $t1, $a2, $a3
sub $s0, $t0, $t1 
add $v0, $s0,$0
machine code in hexadecimal:-
0x2010000A
0x20110009
0xAFB0FFF0
0xAFB1FFF8
0x8FB2FFF8
0x23BDFFFC
0x23BDFFF8
0x23BDFFF4
0x23BDFFF0
0x23BDFFEC
0x23BDFFE4
0x23BDFFE0
0x8FB30000
//expected output:-
s0: 10
s1:  9
Test Case #8
add $t0,$zero,$zero
addi $t1,$zero,20
while:addi $t1,$t1,-1
addi $t0,$t0,1
slt $t2,$zero,EXIT
j while
EXIT:
machine code in hex:-
0x00004020
0x20090014
0x2129ffff
0x21080001
0x01284020
0x0100502a
0x11000001
0x08100002
expected output 
$t0=0x00000000
$t1=0xffffffeb
Test Case #9
addi $s3,$0,10
addi $s4,$0,4
addi $s1,$zero,4
addi $s2,$zero,7
bne $s3, $s4, Else
add $s0, $s1, $s2
j Exit
Else: sub $s0, $s1, $s2
Exit:
Machine code:-
0x2013000a
0x20140004
0x20110004
0x20120007
0x16740002
0x02328020
0x01000004
0x02328020
expected output :
$s3=10
$s4=4
$s1=4
$s2=7
$s0=-3
Test Case #10
addi $s0, $0, 1
add $s1, $0, $0
addi $t0, $0, 128
while: beq $s0, $t0, done
sll $s0, $s0, 1
addi $s1, $s1, 1
j while
done:
machine code:-
0x20100001
0x00008820
0x12080003
0x00108040
0x22310001
0x08100003
expected output:-
$s0=0x00000080 #128
$s1=0x00000007 #7
